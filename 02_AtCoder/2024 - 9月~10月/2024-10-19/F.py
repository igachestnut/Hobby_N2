""" B問題とは違って、

逆手を固定しなくてもよい。
それにより、

現在のqueだけに着目するならば、
最短回数の比較対象に moveh-T間の最短距離 + notmoveh-T +1回だけ必要になる。

また、次のque の処理において、初期条件が変わることになるため、
時計回りで実装したときと、それ以外の時の両方の結果を残しておかなければならない。
初期条件がいっつも2つになるなら幾分か実装はシンプルだが、、、
あるque開始時点で [1,5], [2,5], [3, 5]それぞれの可能性があるとかになると、非常にややこしいことになる。
"""

def check() :
    return


def main() :
    N, Q = map(int, input().split())
    return


if __name__ == "__main__" :
    main()
    #check()
