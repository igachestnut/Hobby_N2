""" #####################################################
発想

方法2. 
- dpを利用して解きたいのコーナー
- 計算量は 2**N * NM から、NM に抑えられる?


- 到達できないと確定した時点で、その結果を除外する的な考え方?
- 全部の本を買ったときに最大能力値Amax_iを調べる、
- Amax_i から減算していき、Xを下回るdpは終了、

dp 構造について考えてみる。
       横軸 Xの余裕値?
縦軸   0000000000
本数N? 0000000000, ----------
       0000000000, ----------, xxxxxxxxxx, yyyyyyyyyy
              
横軸をXのすべての可能性ではなく、作成されたqueue形式にすると、なんぼか計算量は抑えられそう。
とはいえ、中身がやっぱり最大 2**N個だけ作成されてしまいそうではある。
→計算orderは2**Nになってしまうのかな...
作成されるデータの量は、最大2**N個

dp[0] = 1
dp[1] = dp[0] *2 = 2
dp[2] = dp[1] *2 = dp[0]* 2**2 = 4
...
dp[12] = dp[0]* 2**11

あれ。全然dpで作成する意味なさそう。
なんというか、別のdp定義が求められる

...そうか。dpの有用性を生かせていない理由がわかった。
現在queue形式で整えているdp形式がFailということ。
現在考えられるその値段において、**最も効率的な結果**をdpとして残す必要があるが
現在はすべての可能性を残してしまっているから駄目だ。

この問題において、mが12種類あることから、
2つの答えでどっちのほうが効率的か確定することができない。
→これがdpを実装できない理由(方法2の反例)

##################################################### """
def check() :
    return


def main() :
    return


if __name__ == "__main__" :
    main()
    #check()
