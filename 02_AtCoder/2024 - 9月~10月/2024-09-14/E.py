""" 
発想






[問題](https://atcoder.jp/contests/abc371/tasks/abc371_e)
[解説](https://atcoder.jp/contests/abc371/editorial/10922)
[参考資料 - Quita - 部分文字列の列挙](https://qiita.com/drken/items/a207e5ae3ea2cf17f4bd)


475点
この手の部分文字列を列挙する問題は、400~475点に分類される印象。



...問題を解く前に、ぬぐい切れない疑問点
- どうしてこのアルゴリズムで、「被り無く、不足ない」全列挙ができるのか。
    - 次に来る文字の可能性は a~zのいずれか。それ以外はない。これを全indexで実施しているから?

    - dpが格納する数字を見ても不思議で仕方がない。最終的なdpの構造としては、indexが増えることにより増えがちである。
        - dp[0] = 1
        - dp[1] = 1
        - dp[2] = 2
        - dp[3] = 4
        ...
        - dp[i] = X #莫大な数。
        答えはsum(dp)-dp[0]
        これで漏れがない。ううん不思議だ。
    
    - 該当するindexに 加算することは分かった。しかし、1ではなく、dp[i]を加算する理由
        新しい文字列というのは、現在地点i で列挙されているdp[i] の全種類と、次に該当する文字列をで構成される。だから既知のdp[i]を使う。


- dp[i] (の定義):=
    文字列Sにおいて、 i-1 番目の文字(0-indexed)は必ず使うものとして、Sのうち0番目からi-1番目の部分から得られる部分文字列の個数





- 必要なもの
    1. 入力S文字列で、各index(i < N)において、i 以降で最も早く表れるa to z の位置を記したnext2次元配列
    2. dp[0]

- dpの遷移イメージ
    1. dp[0]は最初
    2. 1 <= i <= N まで実行。Sのi番目を選び実行する。
        注意: dpは0 ~ Nまで。 実施する作業(繰り返す回数)は, 0~N-1 のlen(S)だけ実行する。




-------------------------------------------------
Ansではないが、dpの実施方法が分かった気がするのでメモする。

使用する考え方。
- 部分文字列の列挙する方法 , 連続部分文字列を列挙する方法
- 余事法

前提の考え方。
- 今回のMax数値について
    - N = 4で入力のすべての値が[1,2,3,4]のように違う値の時
    しぐま f[i,j] = N(N-1)//2だけある。(初項1, 等差1の等差数列)だけ種類があり、それぞれ
    1, 1,2 2 1,2,3 2,3 3, 1,2,3,4 2,3,4 3,4, 4
    1+ 2+  1+3+    2+  1+ 4+      3+    2+   1
    for i in range(1, N+1) : result += i*(i-1)//2 if i >= 2 else 1 であるな。#1~Nまで実行, それぞれ等差数列だけの数を＋する

余除法で実施するイメージ
1. 今回出てくる数字の種類は 1~2*10**5 である。この数値の変化を仮にi としよう
2. 


注意点
- E.pyに記載しているアルゴリズムは、 1,3のような順序は変わらないが間が抜けている数値が来る。
この部分は避ける。    


"""

def cheaker() :
    return


def main() :
    """ 
    
    
    - dp の遷移イメージ - 1roopで何を加算しているのか?

    部分文字列の例として、 "abcde" があるとする。
    dpは動的計画法であり、この実装もaの着目が終了するともう舞い戻って作業する必要がない。
    では、どうやれば値を確定できるのか? 
    dp[0] = 1 というのは、""を1として数えているイメージ。
    最初のループで、a,b,c,d,eという文字が検出され、dpに加算される。
    これは、それぞれで,「 "" + "a", "" + "b",,,」 が検出された
    という風なイメージである。

    では、dp[i], dp[i+1]ではどうだろう
    b,c,d,e という文字列が検出されたとする。
    dp[1] = 1 === "a"である。これを用いて新しくa to zで文字を作成する。
    それぞれで、「"a" +"a", "a", "b", 」みたいな感じ
    dp[2] = 2 === "b", "ab" に該当する。
    それぞれで、「["b" + "a", "ab" + "a"], ["b" + "b", "ab" + "b"],」
    
    
    なら, "a, ab, abc"という風に増えていくバージョン(1)と, "abcde, bcde, cde"のように減っていく部分文字列(2)が挙げられる。
    この文字列(1)は現在
    
    """
    S = input()
    
    ###全ての部分文字列の総種類数を計算するアルゴリズム。
    # 事前準備。a~zの任意文字=s とする。i番目以降のindexにおいて最も早くsが生じる位置S[?]はどこなのかを記入する便利配列
    def calucrate_next_index(S:str) -> list :
        """ 便利配列の作成
        
        example
        -------------------
        - S="abcde"
            result = [
                [ 1,  2,  3,  4,  5, -1,,,],  #0 未選択
                [-1,  2,  3,  4,  5, -1,,,],  #1 a 選択後の情報
                [-1, -1,  3,  4,  5, -1,,,],  #2 b 
                [-1, -1, -1,  4,  5, -1,,,],  #3 c
                [-1, -1, -1, -1,  5, -1,,,],  #4 d
                [-1, -1, -1, -1, -1, -1,,,]   #5 e
            ]
        
        注意点
        - 入力Sの着目点と、作成する配列のindexの順番がずれている。
            - Sの着目点 : 0~N-1 (Nだと index out of range)
            - result   : 0, 1~N (リスト作成の都合上こうなる。)
        """
        result = [[-1 for az in range(26)] for i in range(len(S)+1)] #i は0(未選択), 1~N まで。result[N]は次のindexが存在しない為必ず-1になる。
        for i in range(len(S)-1, -1, -1) : #N-1から0まで実行する。"abcde"のeから取り出すイメージ
            for j in range(0, 27) : result[i][j] = result[i+1][j] #最も出てくるであろうindexの引継ぎ
            result[i][ord(S[i]) - ord("A")] = i+1 #ここで"abcde"の"e"において、i=4, result[i]は "abcd"以降の情報を格納したい。  
        return result        
    
    # 事前準備
    mynext = calucrate_next_index(S)
    
    # 計算の開始
    dp = [0 for i in range(len(S+1))]
    dp[0] = 1
    for i in range(len(S)) :
        sj = ord[S[i]] - ord["A"] #現在着目しているアルファベットの番号
        
    
    
    
    
    return


if __name__ == "__main__" :
    main()
    #cheaker()
