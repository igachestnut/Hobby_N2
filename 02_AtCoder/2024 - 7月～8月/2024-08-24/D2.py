""" この問題が難しいと感じた理由

各Nodeにおいて、最短親の経路が1種類ではないこと。
現在のNode情報のつながりだけでは、経路選択が不可能であること。
親となるNodeを貪欲法で決定することができない。なぜなら、見つけたいVの最短レベルが1ではない場合があるから。
    すると、Level1は結局何を選べばいいの？ってことになる。


じゃあVをブロック化して考えれば良いのでは？どうやって？実装するの？


解説を見て思ったこと。
まず前提が間違っていた。
もしK=1 調査Node数が1つのばあいそれで完結する。わざわざ最上階まで調べる必要がない。

最短経路を探索するのではなく、
必要ないNodeを調査して破壊していくという考え方。
証明：悪い頂点は条件に応じて良い頂点に変更することは無いから。


間違っていた前提２つめ
指定されたK個の頂点Vをすべて含むような頂点数の最小値を答えて。
つながっていればそれでいいという考え方。


---------------------------------------
この問題の計算量について考える。

edgeの作成 N
各辺からの辺の数調査 N
各辺からの辺が一つしか存在しない場合の調査 N

全ての孤立点の調査 <Nと予想。もしかしたら
for v in q 最悪計算量Nだがこれは,,,,,,
qは常に大きくなりすぎないだろうという憶測が感じられる。



"""
N,K = map(int,input().split())
edge = [set() for _ in range(N)]

for _ in range(N-1):
  a,b = map(int,input().split())
  a-=1
  b-=1
  edge[a].add(b)
  edge[b].add(a)

V = set(map(int,input().split()))
V = set(x-1 for x in V)

deg = [len(s) for s in edge]
q = [i for i,d in enumerate(deg) if d==1]
print(f"deg: {deg}") #そのNodeにおけるつながり辺数
print(f"q : {q}") #つながりが一つしかないようなNodeの番号

ans = N
for v in q:
  if v in V: continue
  vv = edge[v].pop()
  edge[vv].discard(v)#多分vvはリストで、vの辺である。この辺に存在するすべてのv要素を削除している。
  ans-=1
  if len(edge[vv])==1: q.append(vv) #vを削除した結果、孤立している要素なら削除候補に追加しようとしている。

print(ans)


