""" #####################################################
発想

- 1~10**9 の範囲のN で最も大きいN を購入する

- A=1, B=2の時、Nの遷移
    - N= 10
        - 10*A + 2*B = 10*1 + 2*2

- 解消したい疑問
    - Nが増えれば答えは単調増加になるのか？
    ...なりそう。なぜなら、
    - n の時
        - A*n + B*(len(n))
    - n+1のとき
        - A*(n+1) + B*(len(n+1)) 
        = A*n + B*len(n+1) + A
        B*len(n+1) >= B*len(n) であるため
        = f(n+1) >= f(n) + A 
        となる。また、A,Bは整数である。
        QED

- 単調増加であることがわかったら、2分探索でXに近い位置を調査すればよいのみ。
実装方法
- お小遣いX で購入できる最も高いnを導出したい
- OK,NGの差が1になるまで実行。
- OKは現時点で答えとして出力してよい範囲
- NGはダメな範囲

        


        
##################################################### """
def check() :
    return


def main() :
    A, B, X = map(int, input().split())
    OK, NG = 0, 10**9+1
    while NG-OK > 1 :
        tmp_N = (NG+OK)//2
        fn = A*tmp_N + B*len(str(tmp_N))
        if fn > X :
            NG = tmp_N
        else :
            OK = tmp_N
    print(OK)
    return


if __name__ == "__main__" :
    main()
    #check()
