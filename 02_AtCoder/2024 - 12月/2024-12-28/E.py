""" ##########################################

- NCK <= 10**6
- K<= N <= 10**5
- A <= 2**60


- 全数調査
1. 組み合わせ一つ一つに挑戦
2. 1回あたり最大 K回のbit演算作業を行う。

O(NCK * K)回 足りません
...どうにかしてbit演算のうちある程度の処理を省略できないだろうか?

...BFSではどうだろうか???
- 現在までの数値を確定、Kかい選ぶまで実行.


...解説見ました。
まず、組み合わせを全列挙する方法は、
1~i~N において、i=1なら 
- 選ぶ
- 選ばない
次のi(i=2)へ移行する
という流れになる。

しかし、BFSでK回を選ぶ時の制約で言うなら10**6 以内という制約はあるものの、
(N,K)=(100,98)の時、
うまいこと実装しなければ、(100,50)を踏んでしまうことになる(不要な調査をしてしまうことになる)
そこで、解説は、N-K <Kの時、Kを選ばない方向での調査をしたらどうかということを指定していた。
N-K > K の時は、そのままNCKをBFSで実施する。

...min(N-K, K)と探索するときの、
計算量としては、
- 全数探索用の O(N Comb min(N-K,K)) 
- ある組み合わせにおける数 O(min(N-K,K))
になる。
...ここで解説のエスパーポイント。この場合の(min(N-K,K))<=11であるらしい。
...なので、十分高速らしい。むずいね。



############################################# """

def check() :
    return


def main() :
    N,K = map(int, input().split())

    return


if __name__ == "__main__" :
    main()
    #check()
