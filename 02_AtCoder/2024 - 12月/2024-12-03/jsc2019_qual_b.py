""" #####################################################
発想

- 転倒数の導出
- Bi > Bjを満たすものの個数。
0~i~K*N-2
1~j~K*N-1

- ex
K=1だった時を考える。
A = 5 4 3 2 1
i=0の時の転倒数 = 4個
i=1の時の転倒数 = 3個
...
i=3の時の転倒数 = 1個

K=2だった時を考える
A = 5 4 3 2 1  5 4 3 2 1
i=0の時の転倒数 = 4+4個
i=1の時の転倒数 = 3+3個
...
今回のケースでは、i以下数字kで Bi>Bkとなるものが存在しなかったためなんとも言えないが、
転倒数 = iより右側にある、ループ無しの転倒数 + 残りループ数*配列A全体の転倒数。 という式が立てられそう。
- とりあえず全数調査に必要な最低限の情報
    1. i以上A内での転倒数(Biより小さな要素で、右に位置するものの総数)
    2. A全体で見た転倒数(Biより小さな要素すべて)
    - 制約N<2000なので、この情報を計算すること自体は全数でも間に合いそう。
- Kの制約について
    - K<10**9 なので、配列Bの全数調査をするなら間に合わない。
    - なので、N回調査したら答えを導出を目指す。

- 数値の繰り返しについて考える。
1 2 3 2 1 というAがあるとして、Kが10だった時、
- i=3 においては、
    - Aだけ着目時点の右の総数 = 2 = u
    - Aだけ着目全体のの総数   = 4 = v
    なので、
    u+kv (kは0~K-1まで)
    siguma_{0~K-1}(u+kv)

これを今はO(K)だが、O(1)を目指す。
まず、
- Kの繰り返し回数より、u部分の総和 = uK である。
- kvの総和
    - 0v + 1v+ 2v+ ...9v  ((K-1)v)
    1,9 2,8 3,7 4,6 ,5= 45 =10*(10-1)/2 9*5 = K*(K-1)/2
    K*(K-1)/2*v
    これでkv部分の総和がわかった
以上よりO(K)のO(1)化が終了した。


##################################################### """
def check() :
    return


def main() :
    """ 計算量O(N**2+N) 一応(N**2)*2 + N)解法
    
    Aだけに着目したとき、iより右側に位置する転倒数の総数を記したリストu
    Aだけに着目したとき、位置関係なくAiに対する転倒数を記したリストv
    を用いて計算する

    ans転倒数は、配列Bにおけるi(1~i~NK)の転倒数となっている
    i+k*0, i+k*1,,, i+k*(K-1) (0~k~K-1)は同じ数字が出てくる。
    この時の転倒数の合計をikとすると、あるikの合計転倒数は
    u,vを用いて、siguma_{0~K-1}(u+kv)となる。
    u部分の総和はu*K,
    v部分の総和はv*K*(K-1)/2 となるため
    ikの転倒数は (u*K+v*K*(K-1)/2)mod10**9+7となる。
    """
    N,K = map(int, input().split())
    A = list(map(int, input().split()))
    u,v = [],[]
    for i in range(N) :
        tmp_u = 0
        for j in range(i+1, N) :
            if A[i] > A[j] :
                tmp_u +=1
        u.append(tmp_u)
        tmp_v = 0
        for j in range(N) :
            if A[i] > A[j] :
                tmp_v +=1
        v.append(tmp_v)
    
    result = 0
    for i in range(N) :
        result = (result+ u[i]*K+v[i]*K*(K-1)//2)%(10**9+7)
    
    print(result)
    return


if __name__ == "__main__" :
    main()
    #check()
