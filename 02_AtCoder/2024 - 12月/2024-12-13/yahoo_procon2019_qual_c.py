""" #####################################################
発想


1. 1枚増やす
2. A枚を1円に交換する
3. 1円をビスケットB枚に交換する

- まず1.3. はビスケットを入手する方法であり、
Bが1であれば1.が優先される。

DPでやる???
前の状態は、ビスケットを叩いている or ビスケットA枚を1円に交換する or 3のクエリ。
できない状態 = -1 として置いて、

...Kの制約が10**9 なので間に合わない。
- ex) A=1, B=1の時
  bsi_c, money
0     1,     0 
1     2,     0 or 0,   1

最大の枚数を取得したい。
2回の処理のうち、
    1. のクエリなら +2 で終了。
    2,3. を利用できるなら、
    -A+B となる。
    この数が2よりも大きい場合、叩いて増やすより、効率的に増やすことができる。
    すると、答えは
    最初A枚をそろえるまで+ 残りの枚数%2 の数だけ1のクエリ N
    +
    -A+B * (K-N)//2


##################################################### """
def check() :
    return


def main() :
    K, A, B = map(int, input().split())
    K+=1 #初期所持数を1枚からビスケット0枚に変更し、queであるKを増やす
    if B-A <= 2 :
        print(K)
    else :
        if K < A+1 :
            print(K)
        else :
            #N=ビスケットをたたいた回数
            N = A + (K-A)%2
            print(N+ (B-A)*(K-N)//2) 
    return


if __name__ == "__main__" :
    main()
    #check()
