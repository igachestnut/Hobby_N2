""" #####################################

- 考察1

文字数nにおける、文字の[組み合わせ]の数。
もしすべての文字に制限が無ければ、
等差数列で表せられる

f(n) = 1+2+...n


- その文字における、並べ方の種類
文字数の最大をniとする時、
各アルファベットの番号をCi, 各アルファベットの使用文字数をCijとすると


シグマ ni C Ci[Cij]  (sum(Cij)=niと同値である)
i=1


- 考察2
順序を考える

a - a
a - b
a - c

b - a
b - b
b - c

文字数に制限が無ければ、
使用する文字数= kとすると
使用できる文字の種類 = cとすると

c^kと書けそう。


ここにどうやって使用できる文字の数に制限を付けていくのかという話ですな。












- 計算する発想

1. for 使用する文字数から、最大Kまで実施する
具体的には、
文字数1で作成できる名前の候補はいくつ？
文字数2で作成できる名前の候補はいくつ？
...
文字数Kで作成できる名前の候補はいくつ？

def get_count_of_conbinations(jint):
もじ数Jにおいて、配列の条件から、作成できる文字の候補！を出力する関数

もし条件設定が無い(全ての文字が無制限に使えるとき、作成できる文字のコンビネーションは、)





################################## """



def cheaker() :
    return


def main() :
    K = int(input())
    C = list(map(int, input().split()))
    
    
    return


if __name__ == "__main__" :
    main()
    #cheaker()
