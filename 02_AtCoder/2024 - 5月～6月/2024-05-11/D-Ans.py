""" ############################

用語
    j = 現在着目している数字のindex(0<=j<N)
    i = 現在着目している数字より前のindex(0<=i<j)
    

発想
    - 出来ればO(N)で実行したいね
    
    - 法則1と法則2の違い
        yを全て求めようとするパターンと
        xを全て求めようとするパターンを2つに分けて考えると良いかも

    - 法則1
    ある数Aiは、
        xに該当する場合...(1)
        yに該当する場合...(2)
        の2パターン存在する
        
    (1)の場合、10**(len(str(Ai(後ろの数の倍率による))))
    (2)の場合は、そのまま加算するだけ。出現数、(j-1)
    
    - 法則2
    j, j+1を考える
    (1)に該当する数値、10**n倍して加算しないといけない数値、
    これは、前者の数値の総和なんじゃない？
    
    1, 10, 100から
    1, 10, 100, 1000
    で1000に着目している時点で、
    (1)に該当する数値は、
    1*10^(len(1000)) + 10*10^(len(1000)) + 100*10^(len(1000)) 
    = 1*10^(3) + 10*10^(3) + 100*10^(3) 
    = (1+10+100) * 10^3
    なんじゃない？
    
    じゃぁ、j, からj+1の地点で、全てのxに該当しそうな文字を保持しておけば、答えが出せそう。

############################ """

def cheaker() :
    return


def main() :
    N = int(input())
    A = list(map(int, input().split()))
    
    result = 0 #結果
    x_sum  = 0 #functionでいうxで加算されそうな量
    for n in range(N) :
        #yの加算
        result += A[n] *n
        
        #xの加算
        result += (x_sum * 10**len(str(A[n]))) %998244353 #大きい数字になりやすいと思われるためいちいち割り算
        
        #xの加算(次の計算の準備)
        x_sum += A[n]
        
    print(result % 998244353)
        
        
    return

def main_min_code() :
    """ 趣味 最小のコードにしたら"""



    N = int(input())
    A = list(map(int, input().split()))
    result, x_sum = 0, 0 
    for n in range(N) :
        result += A[n] *n + (x_sum * 10**len(str(A[n]))) %998244353
        x_sum += A[n]
    print(result % 998244353)


    return


if __name__ == "__main__" :
    main()
    #cheaker()
