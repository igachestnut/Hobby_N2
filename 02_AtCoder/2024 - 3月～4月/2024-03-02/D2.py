""" //////////////////////////////////////////////////////////////////////

攻略方法
    ・連想配列の考え方を用いる
        現在保持されている点数を添字（辞書名）
        中身をそれに該当する人の番号
        
MEMO
    連想配列によって生じる計算量について疑問メモ
        ある人xを見つけ出すにあたって、配列を全探索しなければならないのでは？
        →2*10**5分の探索を行わないといけないのでは？
    
解説
    1 連想配列Mを作成する
    2 Mに添え字を追加し、M[0]=Nとする
    3 各選手の現在の特典を保持する配列Cを用意、全て0で初期化をする
    4 M[変更される点数]を1減らす
      Cに新しい点数を追加。
      Mに新しい点数の添え字となりうる場所に1追加もしくは新規作成
      
    
アイデアのまとめ  
    自作データベースで状態保持という考え方。
        もし入力によって生じるリストだけで情報を完結させることが不可能な場合、自作の状態保持リスト（今回は連想配列）を作成して、
        状態を保持してみる。
    
////////////////////////////////////////////////////////////////////// """

def cheaker() :
    return


def main() :
    N, T = map(int, input().split())
    
    #全選手の点数を格納したリストの作成
    players_score = [0 for _ in range(N)]
    
    #ユニークスコア（）を添え字、その点数を持つ人間の数を数値にした辞書型リストの作成
    d = {"0" : N}
    
    #処理の開始
    for i in range(T) :
        a,b = map(int, input().split())
        
        #変更するスコアに該当する変数を減らす
        d[str(players_score[a-1])] -= 1
        if d[str(players_score[a-1])] == 0 :
            del d[str(players_score[a-1])]
        
        #値の変更
        players_score[a-1] += b
        
        #新しいデータが無かった場合追加
        if not str(players_score[a-1]) in d :
            d[str(players_score[a-1])] = 0
        #加算処理
        d[str(players_score[a-1])] += 1
        
        print(len(d))             
        
        
    return


if __name__ == "__main__" :
    main()
    #cheaker()
