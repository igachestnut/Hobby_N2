""" #############################################

- 1~Nまでの変数でl, rを移動し、連続する文字列を自由に定義する。
定義された文字列の合計をmodで割った答え
それを定義できるすべての文字列文加算したらどうなる?

連続する文字列の種類
= N**2 

各配列においてsumする処理
最大N

つまり、N**3だけの計算量がある。
連続する文字列の種類に関しては、O(NlogN)で抑える必要がありそうだし、
各mod計算には O(1)が必要そう。
→ある区間のmod計算は累積和で解決しそう。

連続する文字列の種類はどうやって列挙するのがいいのだろうか
にするのだろうか...

とりあえずrを固定して考えるか?

1,2,3,..i,,Nと遷移するとき
dp[i+1] = dp[i] + i*A[i]な気が。

合計= sum(dp)
ただし dp[1] = 1,1 想定とすると
dp[2] = 2,1 2,2 で、2,2は簡単なA[2]のmod計算だが、2,1が (1,1 + 2,2 )mod M 計算なので、ちょいややこしくなりそう

M 1100の時
(2,1) = 110
(1,1) = 1000
(2,2) = 210

こうなってしまう

...答え合わせの時間です
とりあえずAを累積和Sで、各mod計算した状態で定義する。


\sigma_{r=1 ~N} Sr*r - \sigma_{l=1~r}Sl M×Xr

そのあと,X を
Fenwick tree
で導出するらしい。

############################################# """
def check() :
    return


def main() :
    N, M = map(int, input().split())
    A = list(map(int, input().split()))
    ruiseki_A = [0]
    for i in range(N) :
        ruiseki_A.append(ruiseki_A[-1]+A[i])
    result = 0
    for i in range(1, N+1) :
        result += ((i)*(ruiseki_A[i]-ruiseki_A[i-1])) % M
    print(result)
    return


if __name__ == "__main__" :
    main()
    #check()
