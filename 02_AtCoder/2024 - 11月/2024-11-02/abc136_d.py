""" #####################################################
発想

RRLLLLRLRRLL
111111111111
022110
023100
033000

テストケース3-01
RRL
021 ...1
012 ...2

テストケース3
RRLLL
02210 ...1
02300 ...2
03200 ...3
02300 ...4

テストケース3-2
RRRRL
01121 ...1
00122 ...2
00032 ...3
00023 ...4

テストケース4
RLLLLL
121110
221100
231000
330000

まず、S[i],S[i+1] == RL ならその場所に文字が必ず発生する。
RR = 加算処理
RL = 終着点確定
LL = 加算処理
LR = 最後の加算処理+, 新たな文字追加

10**100回後の状態なので、偶奇性で判断したいところ
テストケース3において、02300 or 03200 どっちで終わるのだろうか

...まず分かったこと、
Rから始まり、LRで終了する文字列を考える。それを1groupとする。
len(1group)==偶数の時、
    必ずRLの文字列上にlen(1group)//2, len(1group)//2
である。

処理回数10**100回後 = 偶数回処理後の話。

len(1group)==奇数回
    構成はいずれも 偶数R+奇数L or 奇数R+偶数Lである。
    エスパーポイント、多分奇数のほうに必ず+1される

##################################################### """
def check() :
    return


def main() :
    S = input() + "R"
    result = [0 for i in range(len(S))] #結果を記入する配列
    r,l = 0,0 #R,L が出てきた回数
    end_ri = 0 #RL の Rの位置
    for i in range(len(S)-1) :
        # 次の状態を確認しつつ、i位置の答えを加算する
        if S[i:i+2] == "RR": 
            r += 1
        elif S[i:i+2] == "RL":
            r += 1
            end_ri = i
        elif S[i:i+2] == "LL":
            l += 1
        elif S[i:i+2] == "LR":
            l += 1
            if (r+l) %2 == 0 :
                result[end_ri] = (r+l)//2
                result[end_ri+1] = (r+l)//2
            else :
                result[end_ri] = (r+l)//2 + r%2
                result[end_ri+1] = (r+l)//2 + l%2
            r,l = 0,0
        else :
            #print(S[i], S[i+1])
            raise ValueError("検知する文字列がおかしいです")
    print(*result[:-1])
    return


if __name__ == "__main__" :
    main()
    #check()
