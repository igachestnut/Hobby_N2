""" #####################################################
発想


# 各Nodeからの 最短距離が1~Kになる場合の、各本数を導出して。
- X-Yを経由して考えられるすべての経路をワーシャルフロイド法で列挙する?
for k 
    i
        j
    - いや、ワーシャルフロイド法は原点1からの距離である。

- まず、全数調査しようとするとどれくらいの計算量?
    - 各Nodeから到達できる位置と、その距離の列挙、 sigma_{i=1~N-1}(sigma_{j=i+1~N}(f(i,j)))
    - f(i,j)は各Nodeの距離。(経由は不明で、最短距離だけ)
    - N*(N-1)//2だけ存在する→O(N**2)処理

    - 制約より
        N**2 ~ N**2*logN は耐えそう。
    
- 各Node距離 f(i,j)はどうやって求める...?
    - 制約で、X,Yが与えられなかったとき、必ず結果は一意に定まる。
    - for example)
        1→2 で dis=1
    - すると、答え = abs(j-i) になる
    - ではX,Yが与えられたときは???
    - i<=X, and j>=Y の時、その間の距離は1に変化させられる。
    - つまり,i=X, j=Y のf(i, j) = 1 だし、f(i,j) = abs(j-i) - abs(Y-X)ともかけるだろう。

- この問題のコーナーケース
    - 1-2-3-4-5-6-7, X=2, Y=6 の時、
        f(3,6)の結果が、3-4-5-6 =4 よりも、 3-2-6=3 のほうが早いということ。
    - 各Nodeにおいて、あるNodeまでの最短距離をBellmanFordで導出する...?
    - Bellman ford の計算量が、N*(V - 辺の本数) であり、それを前Node分繰り返すのでO(N*N*N)となり間に合わなさそう
    - 


##################################################### """
def check() :
    return


def main() :
    N, X, Y = map(int, input().split())

    return


if __name__ == "__main__" :
    main()
    #check()
