""" #####################################################
発想

N! の正の約数の個数を出力する
1~i~N におけるi番目の約数= 一意に定まっている。
→dpで制御する
dp[0] = 0
dp[1] = 1
正の約数の個数→6の時、1,2,3,6である。

- ...違う。
そう、result%x == 0となる数値の個数の全数を調査せよ。
あといえること。
→ N! の 1~N の数値はすべて必ず入る。

- どうやってかぶりなしで約数の列挙をするのだろうか。
- ある数値Aの約数を列挙するときに必要な計算量 sqrt(A)でよい。
    - A=a*b で、aで割り切れるとするなら、bを確認する必要はない。
    - a*b = a*a = a**2 を満たすaまで見ればよい。→sqrt(A)
- 今回の問題、Aが定義できない。→でかすぎる数値のため。


- a*b の割り切れるか、問題で、a>b となる部分まで調べ上げればよい。
1~1000 は行ける、
N!において、
count 1000*2
残りb N//1000 の数値

正の約数の個数を10**9 +7で割ったあまりなので、
→1つずつ数え上げ→計算量OVERする。
だから、ある程度、dpとか用いないといけなさそう。

素数*素数どうするか

,,, 先輩よりアイデア
- 素数判定する、素数ai の組み合わせ=かぶりなし約数が定義できそうじゃない？
つまり、素数の総数をA, 素数の選ぶ数をiとしたとき
sigma{i=1~A}(ACi)
で答え出そうじゃない???ということ。

そして、今回の素数というのは、1~N <= 1000まで のうちのどれかである。(1000以上の素数は存在しない)
→1~Nまでのすべての素数を列挙すればよい。

- 素数アルゴリズム
    - 2~N の配列があります
    - for i in range(N) : まで実行
        for j in range(2i,N,i) :
            2以上の倍数をすべて列挙して、削除する。

- 素数の組み合わせアルゴリズム
      1     0Cr = 1
     1 1    1Cr = 2
    1 2 1   2Cr = 4
   1 3 3 1  3Cr = 8
  1 4 6 4 1 4Cr = 16 ...

  ACr の総数 = 2**A である。
  ※ただし、0C0, 1C0=何も選ばないときも含まれている
  なので、2以上の素数の組み合わせの総数 = 2**A-1 である。
- Aによって計算量が変わってくる。特にmod計算が必要。
    - Aをbitシフトして、それぞれのmod総数にする。
    - 2**2の時、2**1 *0 + 2**2*1 →2=10
    - 2**3の時、2**1 *1 + 2**2*1 →2=11
    - Aをbitシフト、立っているときその総数 orそのmodを追加する


    
... 待って?
素数が複数使われる場合も存在しない????


##################################################### """
def check() :
    """ bitシフトの計算 """
    N = 100
    result = 0
    x = 1
    while N > 0 :
        if N&1: 
            print("----------")
            print(N)
            print(x)
            result += x
        N >>= 1
        x += x
    print(result)
    return


def main() :
    N = int(input())
    mod = 10**9+7

    # 素数列挙アルゴリズム
    prime_numbers = [1 for i in range(N+1)]
    for i in range(2, N+1) :
        for j in range(2*i, N+1, i) :
            prime_numbers[j] = 0
    print(prime_numbers)

    # 素数の総数
    prime_count = sum(prime_numbers[2:]) #※0, 1の時は素数として含めない。
    #prime_combination_count = 2**prime_count

    # 素数より、組み合わせの総数を計算し mod(10**9+7)する 
    result = 0
    x = 1
    while prime_count > 0 :
        if prime_count&1:
            result = (result+x)%mod
        prime_count >>= 1 #右ビットシフト(小さくする)
        x = (2*x)%mod
    print(result+2) #1の場合, N!自体を追加する
    return


if __name__ == "__main__" :
    main()
    #check()
